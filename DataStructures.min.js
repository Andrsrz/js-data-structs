function addNode(a) { let b = []; return { value: a, children: b, addChild(a) { let c = addNode(a); return b.push(c), c } } } exports.addNode = addNode; function Tree(a) { let b = addNode(a); return { root: b, display() { function a(b, d) { c += "   ".repeat(d) + b.value + " \u279E \n", b.children.length && b.children.forEach(b => { a(b, d + 1) }) } var c = ""; return a(b, 0), c } } } exports.Tree = Tree; function addBinaryNode(a) { return { value: a, left: null, right: null, addChild(a) { let b = addBinaryNode(a); return null === this.left ? this.left = b : this.right = b, b }, addLeftChild(a) { let b = addBinaryNode(a); return this.left = b, b }, addRightChild(a) { let b = addBinaryNode(a); return this.right = b, b } } } exports.addBinaryNode = addBinaryNode; let order = { pre: "pre", post: "post", in: "in" }; exports.order = order; function BinaryTree(a) { let b = addBinaryNode(a); return { root: b, display(a) { function c(a) { null != a && (c(a.left), e += a.value + " ", c(a.right)) } function d(a) { null != a && (d(a.left), d(a.right), e += a.value + " ") } let e = ""; return "post" == a ? d(b) : "pre" == a ? function (a) { null != a && (e += a.value + " ", d(a.left), d(a.right)) }(b) : c(b), e } } } exports.BinaryTree = BinaryTree; function addBinarySearchNode(a) { return { value: a, left: null, right: null, insert(a) { function b(c, d) { return null == c ? d : (a > c.value ? c.right = b(c.right, d) : c.left = b(c.left, d), c) } let c = addBinarySearchNode(a); return b(this, c), c } } } exports.addBinarySearchNode = addBinarySearchNode; function BinarySearchTree(a) { let b = addBinarySearchNode(a); return { root: b, display(a) { function c(a) { null != a && (c(a.left), e += a.value + " ", c(a.right)) } function d(a) { null != a && (d(a.left), d(a.right), e += a.value + " ") } let e = ""; return "post" == a ? d(b) : "pre" == a ? function (a) { null != a && (e += a.value + " ", d(a.left), d(a.right)) }(b) : c(b), e }, search(a) { function c(b) { if (a > b.value) c(b.right); else { if (a == b.value) return b; c(b.left) } } return c(b), -1 } } } exports.BinarySearchTree = BinarySearchTree; function Stack() { let a = []; return { stack: a, push(b) { a.push(b) }, pop() { return a.pop() }, peek() { return a[a.length - 1] }, isEmpty() { return !(0 != a.length) } } } exports.Stack = Stack; function Queue() { let a = []; return { queue: a, enqueue(b) { a.push(b) }, dequeue() { return a.shift() }, peek() { return a[0] }, isEmpty() { return !(0 != a.length) } } } exports.Queue = Queue; function PriorityQueue() { let a = []; return { queue: a, enqueue(b, c) { a.push({ value: b, key: c }), HeapSort(a) }, dequeue() { return a.shift() }, peek() { return a[0].value }, isEmpty() { return !(0 != a.length) } } } exports.PriorityQueue = PriorityQueue; function createGraphNode(a) { let b = []; return { value: a, adjacentNodes: b, addAdjacent(a) { b.push(a) } } } exports.createGraphNode = createGraphNode; function Graph(a = !1, b = !1) { let c = [], d = []; return { directed: a, weighted: b, nodes: c, edges: d, addNode(a) { c.push(createGraphNode(a)) }, getNode(a) { return c.find(b => b.value === a) }, addEdge(a, b, c = 1) { this.getNode(a) === void 0 && this.addNode(a), this.getNode(b) === void 0 && this.addNode(b); let e = this.getNode(a), f = this.getNode(b); e.addAdjacent(f), d.push([e, f, c]), this.directed || (f.addAdjacent(e), d.push([f, e, c])) }, BFS(a) { let b = [], d = this.getNode(a), e = {}; c.forEach(a => { e[a.value] = !1 }), e[d.value] = !0; let f = Queue(); for (f.enqueue(d); !f.isEmpty();) { let a = f.dequeue(); b.push(a.value), a.adjacentNodes.forEach(a => { e[a.value] || (f.enqueue(a), e[a.value] = !0) }) } return b }, DFS(a) { function b(a, c) { c[a.value] = !0, d.push(a.value), a.adjacentNodes.forEach(a => { c[a.value] || b(a, c) }) } let d = [], e = this.getNode(a), f = {}; return c.forEach(a => { f[a.value] = !1 }), b(e, f), d }, fromAdjMatrix(b) { if (b.length != b[0].length) return null; for (let c = 0; c < b.length; c++)if (!a) for (let a = c + 1; a < b[c].length; a++)0 != b[c][a] && (this.weighted ? this.addEdge(c, a, b[c][a]) : this.addEdge(c, a)); else for (let a = 0; a < b[c].length; a++)0 != b[c][a] && (this.weighted ? this.addEdge(c, a, b[c][a]) : this.addEdge(c, a)) }, topologicalSort() { function a(c) { d[c.value] = !0, c.adjacentNodes.forEach(b => { d[b.value] || a(b) }), b.push(c.value) } if (!this.directed) return "Toplogical sort can only be done on Directed Acyclic Graphs"; let b = [], d = {}; return c.forEach(a => { d[a.value] = !1 }), c.forEach(b => { d[b.value] || a(b) }), b.reverse() }, dijkstra(a) { function b(a, b) { let d = Number.MAX_SAFE_INTEGER, e = -1; return c.forEach(c => { !1 == b[c.value] && a[c.value] <= d && (d = a[c.value], e = c) }), e } let e = c.length, f = {}, g = {}; c.forEach(a => { f[a.value] = Number.MAX_SAFE_INTEGER, g[a.value] = !1 }), console.log(d.length), f[this.getNode(a).value] = 0; for (let h, k = 0; k < e; k++)h = b(f, g), g[h.value] = !0, c.forEach(a => { let b = 0; for (const c of d) if (c[0].value == h.value && c[1].value == a.value || c[1].value == h.value && c[2].value == a.value) { b = c[2]; break } !g[a.value] && 0 != b && f[h.value] != Number.MAX_SAFE_INTEGER && f[h.value] + b < f[a.value] && (f[a.value] = f[h.value] + b) }); return f }, findEdgeWeight(a, b) { d.forEach(c => { if (c[0].value == a && c[1].value == b || c[1].value == a && c[2].value == b) return c[2] }) } } } exports.Graph = Graph; let alphabetSize = 26; function createTrieNode() { let a = Array(alphabetSize).fill(null); return { endOfWord: !1, children: a } } exports.createTrieNode = createTrieNode; function Trie() { let a = createTrieNode(); return { root: a, insertWord(b) { let c = b.length, d = a; for (let a, e = 0; e < c; e++)a = b.charCodeAt(e) - 97, null === d.children[a] && (d.children[a] = createTrieNode()), d = d.children[a]; d.endOfWord = !0 }, search(b) { let c = b.length, d = a; for (let a, e = 0; e < c; e++) { if (a = b.charCodeAt(e) - 97, null === d.children[a]) return !1; d = d.children[a] } return null !== d && d.endOfWord } } } exports.Trie = Trie; function powerSet(a, b = 0, c = "") { function d(b = 0, c = "") { return b == f ? void e.push(c.split("")) : void (d(b + 1, c + a[b]), d(b + 1, c)) } let e = [], f = a.length; return d(b = 0, c = ""), e } exports.powerSet = powerSet; function permutations(a) { function b(c, e) { if (1 == e) return void (d += c.join("") + " "); for (let d = 0; d < e; d++)if (b(c, e - 1), 0 == e % 2) { let b = a[d]; a[d] = a[e - 1], a[e - 1] = b } else { let b = a[0]; a[0] = a[e - 1], a[e - 1] = b } } let c = a.length, d = "", e = []; b(a, c); let f = d.split(" "), g = f.slice(0, f.length - 1); return g.forEach(a => { e.push(a.split("")) }), e } exports.permutations = permutations; function createNode(a) { return { value: a, next: null } } exports.createNode = createNode; function LinkedList() { return { head: null, tail: null, length: 0, isEmpty() { return 0 == this.length }, push(a) { let b = createNode(a); return null == this.head ? (this.head = b, this.tail = b, this.length++, b) : (this.tail.next = b, this.tail = b, this.length++, b) }, insertAt(a, b) { if (0 > a || a > this.length) return null; if (a == this.length) { let a = this.push(b); return a } let c = createNode(b); if (0 == a) return c.next = this.head, this.head = c, this.length++, c; let d = this.head, e = 0; for (; a - 1 != e;)d = d.next, e++; return c.next = d.next, d.next = c, this.length++, c }, pop() { let a = this.tail; if (this.tail == this.head) return this.head = null, this.tail = null, this.length--, a; let b = this.head; for (; b.next != a;)b = b.next; return b.next = null, this.tail = b, this.length--, a }, get(a) { if (0 > a || a >= this.length) return null; if (0 == a) return this.head; let b = this.head, c = 0; for (; a != c;)b = b.next, c++; return b }, delete(a) { if (0 > a || a >= this.length) return null; if (0 == a) { let a = this.head; return this.head = this.head.next, this.length--, a } let b = this.head, c = 0; for (; a - 1 != c;)b = b.next, c++; let d = b.next; return d == this.tail && (this.tail = b), b.next = b.next.next, this.length--, d }, display() { let a = this.head, b = ""; for (; null != a.next;)b += a.value.toString() + " \u279E ", a = a.next; return b += a.value.toString(), b } } } exports.LinkedList = LinkedList; function heapify(a, b, c) { let d = c, e = 2 * c + 1, f = 2 * c + 2; if (f < b && a[c].key < a[f].key && (d = f), e < b && a[d].key < a[e].key && (d = e), d != c) { var g = a[c]; a[c] = a[d], a[d] = g, heapify(a, b, d) } } exports.heapify = heapify; function heapifyMin(a, b, c) { let d = c, e = 2 * c + 1, f = 2 * c + 2; if (f < b && a[c].key > a[f].key && (d = f), e < b && a[d].key > a[e].key && (d = e), d != c) { var g = a[c]; a[c] = a[d], a[d] = g, heapifyMin(a, b, d) } } exports.heapifyMin = heapifyMin; function HeapSort(a, b = !1) { let c = a.length; for (let d = parseInt(c / 2 - 1); -1 < d; d--)b ? heapifyMin(a, c, d) : heapify(a, c, d); for (let d, e = c - 1; 0 < e; e--)d = a[e], a[e] = a[0], a[0] = d, b ? heapifyMin(a, e, 0) : heapify(a, e, 0) } exports.HeapSort = HeapSort; function zSearch(a, b) { let c = b + "$" + a, d = c.length, e = b.length, f = [], g = function (a) { let b = a.length, c = Array(b); c[0] = 0; let d = 0, e = 0; for (let f = 1; f < b; f++)if (f > e) { for (d = f, e = f; e < b && a[e - d] == a[e];)e++; c[f] = e - d, e-- } else { let g = f - d; if (c[g] < e - f + 1) c[f] = c[g]; else { for (d = f; e < b && a[e - d] == a[e];)e++; c[f] = e - d, e-- } } return c }(c); for (let c = 0; c < d; c++)g[c] == e && f.push(c - e - 1); return f } exports.zSearch = zSearch; function Nqueens(a) { function b(b, c) { for (i = 0; i < c; i++)if (1 == d[b][i]) return !1; for (i = b, j = c; 0 <= i && 0 <= j; i--, j--)if (1 == d[i][j]) return !1; for (i = b, j = c; 0 <= j && i < a; i++, j--)if (1 == d[i][j]) return !1; return !0 } function c(e) { if (e >= a) return !0; for (let f = 0; f < a; f++)if (b(f, e)) { if (d[f][e] = 1, c(e + 1)) return !0; d[f][e] = 0 } return !1 } let d = Array.from(Array(a), () => Array.from(Array(a), () => 0)); return c(0), d } exports.Nqueens = Nqueens; function LZW(a = null) { let b; return b = a ? a : Array.apply(null, Array(95)).map(function (a, b) { return String.fromCharCode(b + 32) }).join(""), { encode(a) { let c = {}, d = 0; b.split("").forEach(a => { c[a] = d, d += 1 }); let e, f = a.split(""), g = f[0], h = []; for (let b = 1; b < f.length; b++)e = f[b], null == c[g + e] ? (h.push(c[g]), c[g + e] = d, d += 1, g = e) : g += e; return h.push(c[g]), h }, decode(a) { let d = {}, e = 0; b.split("").forEach(a => { d[e] = a, e += 1 }); let f, g, h = a[0], k = d[h], l = k[0]; for (let b = 1; b < a.length; b++)f = a[b], null == d[f] ? (g = d[h], g += l) : g = d[f], k += g, l = g[0], d[e] = d[h] + l, e += 1, h = f; return k } } } exports.LZW = LZW;